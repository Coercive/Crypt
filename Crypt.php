<?php
namespace Coercive\Security\Crypt;

use Exception;

/**
 * Crypt
 * PHP Version 	5
 *
 * @version		1
 * @package 	Coercive\Security\Crypt
 * @link		@link https://github.com/Coercive/Crypt
 *
 * ORIGINAL AUTHOR :
 * @author      Taylor Hornby - Defuse
 * @link        https://github.com/defuse
 * @copyright   (c) 2014-2015, Taylor Hornby - All rights reserved.
 *
 * MODIFIED BY :
 * @author  	Anthony Moral <contact@coercive.fr>
 * @copyright   (c) 2016 - 2017 Anthony Moral
 * @license 	http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License
 */
class Crypt extends AbstractCrypt {

    /**
     * Generate a encryption key based on param.
     *
     * @param string $sString
     * @return string
     */
    static public function createNewKey($sString) {
        return hash(self::KEY_FUNCTION, $sString);
    }

    /**
     * Generate a random encryption key.
     *
     * @return string
     */
    static public function createNewRandomKey() {
        return self::_secureRandom(self::KEY_BYTE_SIZE);
    }

    /**
     * Encrypts a message.
     *
     * @param string $sPlainText : message to encrypt.
     * @param string $sKey : encryption key, a value generated by createNewRandomKey()
     * @return string
     * @throws Exception
     */
    public static function encrypt($sPlainText, $sKey) {

        # Bad Key Size
        if (self::_strlen($sKey) !== self::KEY_BYTE_SIZE) { self::_exception('Key is the wrong size.', __LINE__, __METHOD__); }

        # Generate a sub-key for encryption.
        $sSubKey = self::_HKDF(self::HASH_FUNCTION, $sKey, self::KEY_BYTE_SIZE, self::ENCRYPTION_INFO);

        # Generate a random initialization vector.
        self::_isFunctionExists('openssl_cipher_iv_length');
        $iIvSize = openssl_cipher_iv_length(self::CIPHER_METHOD);
        if ($iIvSize === false || $iIvSize <= 0) { self::_exception('Could not get the IV length from OpenSSL', __LINE__, __METHOD__); }

        /** @var string $sIv */
        $sIv = self::_secureRandom($iIvSize);

        /** @var string $sCipherText */
        $sCipherText = $sIv . self::_plainEncrypt($sPlainText, $sSubKey, $sIv);

        # Generate a sub-key for authentication and apply the HMAC.
        $sAuthKey = self::_HKDF(self::HASH_FUNCTION, $sKey, self::KEY_BYTE_SIZE, self::AUTHENTICATION_INFO);
        $sAuthKey = hash_hmac(self::HASH_FUNCTION, $sCipherText, $sAuthKey, true);
        return $sAuthKey . $sCipherText;
    }

    /**
     * Decrypts a ciphertext.
     *
     * @param string $sCipherText : ciphertext to decrypt
     * @param string $sKey : key that the ciphertext was encrypted with
     * @return string
     * @throws Exception
     */
    public static function decrypt($sCipherText, $sKey) {

        # Extract the HMAC from the front of the ciphertext.
        if (self::_strlen($sCipherText) <= self::MAC_BYTE_SIZE) { self::_exception('Ciphertext is too short.', __LINE__, __METHOD__); }
        $sHMAC = self::_substr($sCipherText, 0, self::MAC_BYTE_SIZE);
        if ($sHMAC === false) { self::_exception('Can\'t extract HMAC.', __LINE__, __METHOD__); }

        # Extract ciphertext
        $sCipherText = self::_substr($sCipherText, self::MAC_BYTE_SIZE);
        if ($sCipherText === false) { self::_exception('Can\'t extract Cipher Text.', __LINE__, __METHOD__); }

        // Regenerate the same authentication sub-key.
        $sAuthKey = self::_HKDF(self::HASH_FUNCTION, $sKey, self::KEY_BYTE_SIZE, self::AUTHENTICATION_INFO);
        if (!self::_verifyHMAC($sHMAC, $sCipherText, $sAuthKey)) {
            /*
             * We throw an exception instead of returning FALSE because we want
             * a script that doesn't handle this condition to CRASH, instead
             * of thinking the ciphertext decrypted to the value FALSE.
             */
            self::_exception('Integrity check failed.', __LINE__, __METHOD__);
        }

        // Regenerate the same encryption sub-key.
        $sEncryptKey = self::_HKDF(self::HASH_FUNCTION, $sKey, self::KEY_BYTE_SIZE, self::ENCRYPTION_INFO);

        // Extract the initialization vector from the ciphertext.
        self::_isFunctionExists('openssl_cipher_iv_length');

        /** @var int initialization vector size */
        $iIvSize = openssl_cipher_iv_length(self::CIPHER_METHOD);
        if ($iIvSize === false || $iIvSize <= 0) { self::_exception('Could not get the IV length from OpenSSL.', __LINE__, __METHOD__); }
        if (self::_strlen($sCipherText) <= $iIvSize) { self::_exception('Ciphertext is too short.', __LINE__, __METHOD__); }

        /** @var string initialization vector */
        $sIv = self::_substr($sCipherText, 0, $iIvSize);
        if ($sIv === false) { self::_exception('Can\'t extract initialization vector.', __LINE__, __METHOD__); }

        /** @var string Extracted Cipher Text */
        $sCipherText = self::_substr($sCipherText, $iIvSize);
        if ($sCipherText === false) { self::_exception('Can\'t extract Cipher Text.', __LINE__, __METHOD__); }
        return self::_plainDecrypt($sCipherText, $sEncryptKey, $sIv);

    }
}